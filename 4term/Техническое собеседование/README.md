# Тест-кейс
### Опишите возможную программную, аппаратную и сетевую архитектуру любого высоконагруженного web-сервиса. 

--- 

![alt text](https://github.com/mafin1799/BMSTU/blob/main/4term/Техническое%20собеседование/web1.jpg?raw=true)
> Общая концепция web-сервиса
---

#### В общем случае web-сервис состоит из:
1. **Frontend**
2. **Backend**
3. **Database**
4. **File Server**

- **Программная архитектура**
	- это как раз наши компоненты, фронт, бэк, базы, API и т.д.
 - **Аппаратная архитектура**
	- С точки зрения "железа", «веб-сервер» — это компьютер, который хранит файлы сайта (HTML-документы, CSS-стили, JavaScript-файлы, картинки и другие) и доставляет их на устройство конечного пользователя (веб-браузер и т.д.). Он подключён к сети Интернет и может быть доступен через доменное имя, подобное mozilla.org.
	- Cервер:
		-  всегда запущен и работает
		-  всегда подключён к Интернету
		-  имеет неизменный IP адрес (не все провайдеры предоставляют статический IP-адрес для домашнего подключения)
	> Когда разработчики не могут себе позволить разворачивать сервер или не хотят - они используют услуги хостинг-провайдера к примеру timeweb
		-
- **Сетевая архитектура**
	- сетевая архитерктура - это то, как компоненты будут коннектится друг к другу, когда один сервер в москве, а другой в магадане
*программе на это всё равно* она просто идёт по определённому домену/ip и даже не знает какой путь проходит запрос
а там уже могут быть намешаны впн,прокси,секьюрити группы и прочая сисадминская история

Запрос от клиента проходит путь: 
* Сначала через DNS он направляется на **Frontend server**
* Если запрос был связан с файлом на **File Server**, то **Frontend server** передаёт его последнему, получает ответ и возвращает пользователю по протоколу HTTP.
* Иначе запрос передаётся по FastCGI к **Backend server**, где находится код самого сервиса, исполняемый файлы, интерпретатор. Если запрос связан с данными из **Database**, то **Backend server** отправляет его к **Database**, где он исполняется, и результат передаёт обратно через **Frontend server** пользователю. Либо исполняет его на своей стороне, если это, например, выполнение функции сервиса, и также отправляет результат пользователю. 
* Далее, с ростом нагрузки, сервера масштабируются. 
	* Сначала вертикально (улучшением существующего сервера)
	* затем, когда дальнейшие улучшения одного нецелесообразны или невозможны, горизонтально (т.е. путём приобретения новых серверов).
	
*При масштабировании до уровня high load происходит разбивка серверов на функциональные группы.*
*В зависимости от нагрузки, один **Frontend server** реплицируется на кластер из нескольких серверов.*
*Один **Backend server** также реплицируется на кластер из нескольких серверов. **Backend server** закрываются во внутренней подсети, чтобы не было возможности доступа к ним у посторонних лиц.*

### Масштабирование
#### Масштабирование back-end

Если нагрузка временная, можно увеличить мощность сервера. 
В ином случае следует разделить back-end на несколько серверов. 
Достаточно перенести часть скриптов и модулей на второй сервер. После этого, необходимо распределить запросы равномерно между ними. Это даст возможность снять нагрузку с основного сервера и перенаправить на другие машины. В основном это делается на front-end стороне.

![alt text](https://github.com/mafin1799/BMSTU/blob/main/4term/Техническое%20собеседование/web3.jpg?raw=true)
> Масштабирование back-end
---
#### Масштабирование базы данных

Если база данных имеет огромное количество данных и нагружает отдельный сервер, можно масштабировать данный кластер. Существует два подхода масштабирования базы данных:
- Распределение вычислительных процессов.
- Разделение базы данных.
##### Распределение вычислительных процессов в базе данных
Если Вы имеете не большую базу данных, но много сложных вычислений, которые нагружают сервер, рекомендуем разделить именно процесс вычислений. 
Таким образом, каждый сервер будет иметь полную копию базы данных и выполнять только свой ограниченный пул работы. 
Это более сложная задача, которая требует больше усилий для реализации. 
В первую очередь это связано с синхронизацией данных между серверами, чтобы держать каждую копию базы данных актуальной. 

Существует несколько походов для решение этой проблемы:

- Синхронизация на уровне приложений. В этом случае скрипты автоматически записывают изменения в каждую копию базы данных. Это подход имеет много рисков, так как любой сбой может нарушить синхронизацию данных.
- Репликация. Позволяет делать изменения на одном «главном» сервере, после этого происходит автоматическое изменения на остальных серверах.
- Multi-master репликация. Очень похож на репликацию, только в этом случае скрипт может обращаться к любому серверу. Репликация будет распространена на остальные сервера.
##### Разделение базы данных
Если у Вас не много вычислений, но база данных состоит из множество записей (часто такие проблемы имеют крупные e-commerce сайты), в этом случае Вам нужно разделить базу данных на несколько серверов. 

Каждый сервер будет иметь часть данных и взаимодействовать с другими серверами.

Существует несколько схем распределения данных:
- Вертикальное (vertical partitioning). Суть данной схемы заключается в том что некоторые таблицы перемещаются на другой сервер. В таком случае теряется гибкость, так как нет возможности сделать сложные SQL запросы. Если провести правильное и логическое разделение базы, этот недостаток можно свести к минимуму.
- Горизонтальное (horizontal partitioning). В данной схеме база данных хранить одну и туже таблицу, только с разными частями. Например, у Вас есть таблица с 100 миллионами записями пользователей. Мы ее раздели на 2 сервера, на одном сервере будут хранится записи только мужчины, а на втором – только женщины. В этом случае необходимо внести изменения в back-end чтобы правильно распределить запросы между серверами.
 
 --- 

![alt text](https://github.com/mafin1799/BMSTU/blob/main/4term/Техническое%20собеседование/web4.jpg?raw=true)
> Масштабирование базы данных
---
 
### Какие технологии целесообразно использовать на серверной и клиентской частях проекта?
**Клиент (сайт):** фронтэнд сайта создаётся с использованием стандартной связки HTML + CSS + JS. Можно использовать фреймворки, как Bootstrap, для быстрой генерации фронтэнда, препроцессоры CSS и HTML для упрощения работы, фреймворки для JavaScript. 
**Сервер: 
- В качестве ОС на всех серверах целесообразно использовать Linux, например, Ubuntu, т.к. Линукс легко администрируем, зачастую опен-сорс, более отказоустойчив. 
- В качестве веб-сервера для фронтенд- и бекэнд-серверов можно выбирать между Nginx и Apache. Но Nginx хорошо подходит для высоконагруженных сервисов, т.к. построен на асинхронной событийно управляемой архитектуре, что помогает обрабатывать большое количество сессий одновременно, не блокируя доступ к каналам ввода-вывода. При этом он легко масштабируем. Но Apache так же можно использовать, его сильная сторона - модульная архитектура. 
- В качестве СУБД подойдёт MySQL, т.к. она очень проста в использовании, масштабируема. 
- Бекэнд приложения можно реализовывать на интерпретируемых языках, как-то: PHP, Python + Django, Ruby on Rails, - но интерпретируемые языки сильно проигрывают в скорости компилируемым на больших нагрузках. В таком случае, самые нересурсоёмкие части кода можно реализовывать на скриптовых языках, остальную часть лучше реализовывать с использованием компилируемых языков, например, Java или C. Таким образом, важно найти баланс между удобством написания кода и производительностью, не собирая при этом громоздкую кучу технологий. 
- Для файлового сервера достаточно лишь необходимых программ для хранения и передачи файлов. Обработка файлов производится на стороне клиента
 
### Как бы вы организовали хранение данных пользователей, файлов?
> Хранение данных пользователей и файлов при высоких нагрузках будет занимать большое количество дискового пространства, следовательно, следует грамотно масштабировать БД. Для этого существует две стратегии - шардинг и репликация. Для некоторых таблиц, например, пользовательских медиа-файлов (таблицы с фотографиями, таблицы с видеозаписями, таблицы с аудиозаписями) уместно одновременное использование обоих подходов. То есть, крупная таблица разбивается на несколько шардов, при этом каждый из шардов дополнительно горизонтально масштабируется. Важно иметь резервные копии каждой из таблиц. Также необходим сервер, хранящий локально только временные файлы, требующиеся на время выполнения запроса и удаляющиеся после завершения его выполнения.  

> Если статических файлов в приложении достаточно много, целесообразно ввести один или кластер из нескольких файловых серверов под управлением ОС Linux и web-сервера nginx на выделенном субдомене для таких серверов. 
 
### Какие способы оптимизации работы под нагрузкой можно применить и в каких случаях?
Оптимизировать можно все основные компоненты приложения. Есть несколько общих стратегий:
- Старые сервера обновлять на новые и, по возможности, более производительные. 
- Проверить код на наличие алгоритмов, хорошо работавших на меньших количествах запросов, но переставших отвечать требованиям с увеличением нагрузки. 
- Также, если основная часть кода реализована на скриптовых языках, можно переписать часть ресурсоёмкого кода на Си или Джава.
- Распараллелить крупный алгоритм на несколько серверов.
Далее, важным инструментом является кэширование. Nginx позволяет кэшировать код. Какой-либо кусок кода с выборкой данных, сложных запросах к API, например, скрипт, генерирующий страницу с фидлентой, его результат можно сохранить в память, откуда будет выдаваться пользователю. При этом раз в t секунд старая страница будет удаляться из памяти, а новая генерироваться и сохраняться снова. Можно кэшировать fastcgi.
***Полезным является использование систем очередей***
Затем остаётся только горизонтальное масштабирование компонентов. Для начала стоит выяснить, какая часть приложения является узким местом. 
- Чаще всего таким узким местом является БД. Для начала, MySQL может быть настроена неверно и неоптимально для текущего железа. В MySQL есть возможность логирования медленных запросов, с помощью которых можно понять, что создаёт реальные проблемы. Как правило, количество select запросов превышает количество запросов на изменение БД. В такой ситуации можно воспользоваться встроенными в MySQL методиками кеширования. Но можно воспользоваться более гибкими внешними решениями, например, Memcache или Redis. При этом кеширование надо использовать как промежуточный этап решения проблемы, при этом по возможности избавляясь от медленных запросов.
Наиболее оптимальным принципом масштабирования БД под высокие нагрузки является шардинг. 
- Если узким местом является бекэнд сервер, то его также можно масштабировать вертикально или горизонтально. При этом, nginx обладает инструментом балансировки нагрузки на бекэнд сервера. Есть 3 метода балансировки:
	- Round Robin - nginx по умолчанию распределяет запросы равномерно между бекэндами, учитывая веса. 
	- least_conn - приоритет на получение запросов имеют сервера с наименьшим количеством активных подключений, с учётом веса.
	- Hash/IP Hash - для каждого запроса nginx вычисляет хэш, который состоит из текста, переменных веб-сервера или их комбинации, а затем сопоставляет его с бекэндами. Таким образом, nginx создаёт своего рода постоянные соединения между определённым клиентом и определённым бекэндом. IP Hash работает также, только хэш вычисляет по IP-адресу клиента.
- Фронтенд как правило выдерживает большие нагрузкие, чем прочие компоненты, но его тоже можно оптимизировать. Для этого используется DNS балансировка, а так же Geo DNS. DNS балансировка производится методом Round Robin. В таком случае клиент будет каждый раз получать адрес домена фронтэнд сервера, равномерно распределяясь между всеми имеющимися. Geo DNS позволяет соединять пользователей с фронтэндами, учитывая их местоположение. Персональные данные пользователя можно сохранять в виде кукис.
 
### Какие способы организации доступности сервиса можно применить в случае форс мажорных ситуаций, выхода из строя любого компонента архитектуры?
**Отказоустойчивость**
---

Если упал один из серверов, нужно перенаправлять/распределять нагрузку на остальные доступные;

Две стратегии: Failover и Fault-tolerance.
- Failover. Выход из строя железа решается посредством избыточности, т.е. когда каждый узел имеет резервную копию, которая возьмёт на себя работу основного при выходе его из строя;
	- Главный принцип - SPOF (Single Point of Failure) - избегать пребывания какого-либо элемента в единственном числе, все компоненты должны быть зарезервированы. 
		- DNS: для одного домена указывается несколько NS записей, чтобы в случае выхода из строя одного из NS сервера запросы обрабатывались другими;
		- Бекенды: выход из строя одного сервера просто увеличивает нагрузку на все остальные, нет необходимости в резервации всех бекенд-серверов.
		- БД: репликация Master-Slave. При выходе мастера из строя, слейв становится мастером. После починки бывшего мастера, он снова реплицируется с бывшим слейвом (ныне мастером) и обратно становится мастер, а слейв обратно становится слейвом.
- Fault-tolerance - система отказоустойчивости, при которой компоненты обладают автоматизированной самодиагностикой.
