# Тест-кейс
### Опишите возможную программную, аппаратную и сетевую архитектуру любого высоконагруженного web-сервиса. 

--- 

![alt text](https://github.com/mafin1799/BMSTU/blob/main/4term/Техническое%20собеседование/web1.jpg?raw=true)
> Общая концепция web-сервиса
---

#### В общем случае web-сервис состоит из:
1. **Frontend**
2. **Backend**
3. **Database**
4. **File Server**

Запрос от клиента проходит путь: 
* Сначала через DNS он направляется на **Frontend server**
* Если запрос был связан с файлом на **File Server**, то **Frontend server** передаёт его последнему, получает ответ и возвращает пользователю по протоколу HTTP.
* Иначе запрос передаётся по FastCGI к **Backend server**, где находится код самого сервиса, исполняемый файлы, интерпретатор. Если запрос связан с данными из **Database**, то **Backend server** отправляет его к **Database**, где он исполняется, и результат передаёт обратно через **Frontend server** пользователю. Либо исполняет его на своей стороне, если это, например, выполнение функции сервиса, и также отправляет результат пользователю. 


- **Программная архитектура**
	- это как раз наши компоненты, фронт, бэк, базы, API и т.д.
 - **Аппаратная архитектура**
	- С точки зрения "железа", «веб-сервер» — это компьютер, который хранит файлы сайта (HTML-документы, CSS-стили, JavaScript-файлы, картинки и другие) и доставляет их на устройство конечного пользователя (веб-браузер и т.д.). Он подключён к сети Интернет и может быть доступен через доменное имя, подобное mozilla.org.
	- Cервер:
		-  всегда запущен и работает
		-  всегда подключён к Интернету
		-  имеет неизменный IP адрес (не все провайдеры предоставляют статический IP-адрес для домашнего подключения)
	> Когда разработчики не могут себе позволить разворачивать сервер или не хотят - они используют услуги хостинг-провайдера к примеру timeweb
		-
- **Сетевая архитектура**
	- сетевая архитерктура - это то, как компоненты будут коннектится друг к другу, когда один сервер в москве, а другой в магадане
*программе на это всё равно* она просто идёт по определённому домену/ip и даже не знает какой путь проходит запрос
а там уже могут быть намешаны впн,прокси,секьюрити группы и прочая сисадминская история



### Масштабирование

* Далее, с ростом нагрузки, сервера масштабируются. 
	* Сначала вертикально (улучшением существующего сервера)
	* затем, когда дальнейшие улучшения одного нецелесообразны или невозможны, горизонтально (т.е. путём приобретения новых серверов).
	
*При масштабировании до уровня high load происходит разбивка серверов на функциональные группы.*
*В зависимости от нагрузки, один **Frontend server** реплицируется на кластер из нескольких серверов.*
*Один **Backend server** также реплицируется на кластер из нескольких серверов. **Backend server** закрываются во внутренней подсети, чтобы не было возможности доступа к ним у посторонних лиц.*

#### Масштабирование back-end

- Если нагрузка временная, можно увеличить мощность сервера. 
- В ином случае следует разделить back-end на несколько серверов. Достаточно перенести часть скриптов и модулей на второй сервер. После этого, необходимо распределить запросы равномерно между ними. Это даст возможность снять нагрузку с основного сервера и перенаправить на другие машины. В основном это делается на front-end стороне.

![alt text](https://github.com/mafin1799/BMSTU/blob/main/4term/Техническое%20собеседование/web3.jpg?raw=true)
> Масштабирование back-end
---
#### Масштабирование базы данных

Если база данных имеет огромное количество данных и нагружает отдельный сервер, можно масштабировать данный кластер. Существует два подхода масштабирования базы данных:
- Распределение вычислительных процессов.
- Разделение базы данных.
##### Распределение вычислительных процессов в базе данных
Существует несколько решений:
- Синхронизация на уровне приложений. В этом случае скрипты автоматически записывают изменения в каждую копию базы данных. Это подход имеет много рисков, так как любой сбой может нарушить синхронизацию данных.
- Репликация. Позволяет делать изменения на одном «главном» сервере, после этого происходит автоматическое изменения на остальных серверах.
- Multi-master репликация. Очень похож на репликацию, только в этом случае скрипт может обращаться к любому серверу. Репликация будет распространена на остальные сервера.
##### Разделение базы данных
Если у Вас не много вычислений, но база данных состоит из множество записей (часто такие проблемы имеют крупные e-commerce сайты), в этом случае нужно разделить базу данных на несколько серверов. 

Каждый сервер будет иметь часть данных и взаимодействовать с другими серверами.

Существует несколько схем распределения данных:
- Вертикальное (vertical partitioning). Суть данной схемы заключается в том что некоторые таблицы перемещаются на другой сервер. В таком случае теряется гибкость, так как нет возможности сделать сложные SQL запросы. Если провести правильное и логическое разделение базы, этот недостаток можно свести к минимуму.
- Горизонтальное (horizontal partitioning). В данной схеме база данных хранить одну и туже таблицу, только с разными частями. Например, у Вас есть таблица с 100 миллионами записями пользователей. Мы ее раздели на 2 сервера, на одном сервере будут хранится записи только мужчины, а на втором – только женщины. В этом случае необходимо внести изменения в back-end чтобы правильно распределить запросы между серверами.
 
 --- 

![alt text](https://github.com/mafin1799/BMSTU/blob/main/4term/Техническое%20собеседование/web4.jpg?raw=true)
> Масштабирование базы данных
---
 
### Какие технологии целесообразно использовать на серверной и клиентской частях проекта?
**Клиент (сайт):** фронтэнд сайта создаётся с использованием стандартной связки HTML + CSS + JS. Можно использовать фреймворки, как Bootstrap, для быстрой генерации фронтэнда, препроцессоры CSS и HTML для упрощения работы, фреймворки для JavaScript. 
**Сервер: 
- В качестве ОС на всех серверах - Linux, например, Ubuntu. 
- В качестве веб-сервера для фронтенд- и бекэнд-серверов используют Nginx или Apache. У каждого свои плюсы и минусы.
- В качестве СУБД - MySQL
- Бекэнд приложения можно реализовывать на интерпретируемых языках: PHP, Python + Django, Ruby on Rails,  но интерпретируемые языки сильно проигрывают в скорости  на больших нагрузках. В таком случае, самые нересурсоёмкие части кода можно реализовывать на скриптовых языках, остальную часть лучше реализовывать с использованием компилируемых языков, например, Golang, Java или C.
- Для файлового сервера достаточно лишь необходимых программ для хранения и передачи файлов. Обработка файлов производится на стороне клиента.
 
### Как бы вы организовали хранение данных пользователей, файлов?
> Хранение данных пользователей и файлов при высоких нагрузках будет занимать большое количество дискового пространства, следовательно, следует грамотно масштабировать БД. Для этого существует две стратегии - шардинг и репликация. Для некоторых таблиц, например, пользовательских медиа-файлов (таблицы с фотографиями, таблицы с видеозаписями, таблицы с аудиозаписями) уместно одновременное использование обоих подходов. То есть, крупная таблица разбивается на несколько шардов, при этом каждый из шардов дополнительно горизонтально масштабируется. Важно иметь резервные копии каждой из таблиц. Также необходим сервер, хранящий локально только временные файлы, требующиеся на время выполнения запроса и удаляющиеся после завершения его выполнения.  

> Если статических файлов в приложении достаточно много, целесообразно ввести один или кластер из нескольких файловых серверов под управлением ОС Linux и web-сервера nginx на выделенном субдомене для таких серверов. 
 
### Какие способы оптимизации работы под нагрузкой можно применить и в каких случаях?
- Старые сервера обновлять на новые и, по возможности, более производительные. 
- Проверить код на наличие алгоритмов, хорошо работавших на меньших количествах запросов, но переставших отвечать требованиям с увеличением нагрузки. 
- Также, если основная часть кода реализована на скриптовых языках, можно переписать часть ресурсоёмкого кода на Си или Джава.
- Распараллелить крупный алгоритм на несколько серверов.
Далее, важным инструментом является кэширование. Nginx позволяет кэшировать код. 
***Полезным является использование систем очередей***
Затем остаётся только горизонтальное масштабирование компонентов. 
- Для БД под высокие нагрузки является шардинг. 
- Если узким местом является Backend-Server, то его также можно масштабировать вертикально или горизонтально. nginx позволяет распределять нагрузку. Есть 3 метода балансировки:
	- Round Robin - nginx по умолчанию распределяет запросы равномерно между бекэндами, учитывая веса. 
	- least_conn - приоритет на получение запросов имеют сервера с наименьшим количеством активных подключений, с учётом веса.
	- Hash/IP Hash - для каждого запроса nginx вычисляет хэш, который состоит из текста, переменных веб-сервера или их комбинации, а затем сопоставляет его с бекэндами. Таким образом, nginx создаёт своего рода постоянные соединения между определённым клиентом и определённым бекэндом. IP Hash работает также, только хэш вычисляет по IP-адресу клиента.
- Фронтенд как правило выдерживает большие нагрузкие, чем прочие компоненты.
 
### Какие способы организации доступности сервиса можно применить в случае форс мажорных ситуаций, выхода из строя любого компонента архитектуры?
**Отказоустойчивость**
---

Если упал один из серверов, нужно перенаправлять/распределять нагрузку на остальные доступные;
- Стратегия Failover. Выход из строя аппаратнойчасти решается посредством избыточности, т.е. когда каждый узел имеет резервную копию, которая возьмёт на себя работу основного при выходе его из строя;
- Главный принцип - SPOF (Single Point of Failure) - избегать пребывания какого-либо элемента в единственном числе, все компоненты должны быть зарезервированы. 
	- DNS: для одного домена указывается несколько NS записей, чтобы в случае выхода из строя одного из NS сервера запросы обрабатывались другими;
	- Backend: выход из строя одного сервера просто увеличивает нагрузку на все остальные, нет необходимости в резервации всех бекенд-серверов.
	- Database: репликация Master-Slave. При выходе мастера из строя, слейв становится мастером. После починки бывшего мастера, он снова реплицируется с бывшим слейвом (ныне мастером) и обратно становится мастер, а слейв обратно становится слейвом.
